// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: ws.proto

package ws

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	ret "github.com/qsock/qim/lib/proto/ret"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ExchangeReq struct {
	Uuid   string `protobuf:"bytes,1,opt,name=uuid,proto3" json:"uuid,omitempty"`
	SessId string `protobuf:"bytes,2,opt,name=sess_id,json=sessId,proto3" json:"sess_id,omitempty"`
}

func (m *ExchangeReq) Reset()         { *m = ExchangeReq{} }
func (m *ExchangeReq) String() string { return proto.CompactTextString(m) }
func (*ExchangeReq) ProtoMessage()    {}
func (*ExchangeReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ff87931dac4ca82, []int{0}
}
func (m *ExchangeReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExchangeReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExchangeReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExchangeReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExchangeReq.Merge(m, src)
}
func (m *ExchangeReq) XXX_Size() int {
	return m.Size()
}
func (m *ExchangeReq) XXX_DiscardUnknown() {
	xxx_messageInfo_ExchangeReq.DiscardUnknown(m)
}

var xxx_messageInfo_ExchangeReq proto.InternalMessageInfo

func (m *ExchangeReq) GetUuid() string {
	if m != nil {
		return m.Uuid
	}
	return ""
}

func (m *ExchangeReq) GetSessId() string {
	if m != nil {
		return m.SessId
	}
	return ""
}

// 发送消息
type MsgReq struct {
	SessId  string `protobuf:"bytes,1,opt,name=sess_id,json=sessId,proto3" json:"sess_id,omitempty"`
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *MsgReq) Reset()         { *m = MsgReq{} }
func (m *MsgReq) String() string { return proto.CompactTextString(m) }
func (*MsgReq) ProtoMessage()    {}
func (*MsgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ff87931dac4ca82, []int{1}
}
func (m *MsgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgReq.Merge(m, src)
}
func (m *MsgReq) XXX_Size() int {
	return m.Size()
}
func (m *MsgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgReq.DiscardUnknown(m)
}

var xxx_messageInfo_MsgReq proto.InternalMessageInfo

func (m *MsgReq) GetSessId() string {
	if m != nil {
		return m.SessId
	}
	return ""
}

func (m *MsgReq) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

// 发送消息
type AllMsgReq struct {
	Content []byte `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *AllMsgReq) Reset()         { *m = AllMsgReq{} }
func (m *AllMsgReq) String() string { return proto.CompactTextString(m) }
func (*AllMsgReq) ProtoMessage()    {}
func (*AllMsgReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ff87931dac4ca82, []int{2}
}
func (m *AllMsgReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllMsgReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllMsgReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllMsgReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllMsgReq.Merge(m, src)
}
func (m *AllMsgReq) XXX_Size() int {
	return m.Size()
}
func (m *AllMsgReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AllMsgReq.DiscardUnknown(m)
}

var xxx_messageInfo_AllMsgReq proto.InternalMessageInfo

func (m *AllMsgReq) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

// 关闭用户
type CloseUserReq struct {
	SessId  string `protobuf:"bytes,1,opt,name=sess_id,json=sessId,proto3" json:"sess_id,omitempty"`
	Content []byte `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
}

func (m *CloseUserReq) Reset()         { *m = CloseUserReq{} }
func (m *CloseUserReq) String() string { return proto.CompactTextString(m) }
func (*CloseUserReq) ProtoMessage()    {}
func (*CloseUserReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ff87931dac4ca82, []int{3}
}
func (m *CloseUserReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CloseUserReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CloseUserReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CloseUserReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CloseUserReq.Merge(m, src)
}
func (m *CloseUserReq) XXX_Size() int {
	return m.Size()
}
func (m *CloseUserReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CloseUserReq.DiscardUnknown(m)
}

var xxx_messageInfo_CloseUserReq proto.InternalMessageInfo

func (m *CloseUserReq) GetSessId() string {
	if m != nil {
		return m.SessId
	}
	return ""
}

func (m *CloseUserReq) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

// 得到在线用户
type IsSessOnlineReq struct {
	SessId string `protobuf:"bytes,1,opt,name=sess_id,json=sessId,proto3" json:"sess_id,omitempty"`
}

func (m *IsSessOnlineReq) Reset()         { *m = IsSessOnlineReq{} }
func (m *IsSessOnlineReq) String() string { return proto.CompactTextString(m) }
func (*IsSessOnlineReq) ProtoMessage()    {}
func (*IsSessOnlineReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_7ff87931dac4ca82, []int{4}
}
func (m *IsSessOnlineReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IsSessOnlineReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IsSessOnlineReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IsSessOnlineReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IsSessOnlineReq.Merge(m, src)
}
func (m *IsSessOnlineReq) XXX_Size() int {
	return m.Size()
}
func (m *IsSessOnlineReq) XXX_DiscardUnknown() {
	xxx_messageInfo_IsSessOnlineReq.DiscardUnknown(m)
}

var xxx_messageInfo_IsSessOnlineReq proto.InternalMessageInfo

func (m *IsSessOnlineReq) GetSessId() string {
	if m != nil {
		return m.SessId
	}
	return ""
}

func init() {
	proto.RegisterType((*ExchangeReq)(nil), "ws.ExchangeReq")
	proto.RegisterType((*MsgReq)(nil), "ws.MsgReq")
	proto.RegisterType((*AllMsgReq)(nil), "ws.AllMsgReq")
	proto.RegisterType((*CloseUserReq)(nil), "ws.CloseUserReq")
	proto.RegisterType((*IsSessOnlineReq)(nil), "ws.IsSessOnlineReq")
}

func init() { proto.RegisterFile("ws.proto", fileDescriptor_7ff87931dac4ca82) }

var fileDescriptor_7ff87931dac4ca82 = []byte{
	// 359 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x92, 0xcf, 0x4a, 0xeb, 0x50,
	0x10, 0xc6, 0x93, 0xdc, 0x92, 0x36, 0xd3, 0xf6, 0xf6, 0x32, 0x77, 0x71, 0x4b, 0x16, 0xe1, 0x1a,
	0x11, 0x54, 0x30, 0x01, 0x75, 0x65, 0x57, 0xad, 0x74, 0xd1, 0x45, 0x55, 0x22, 0x22, 0xb8, 0x11,
	0x9b, 0x1e, 0xd2, 0x60, 0x9a, 0xd3, 0x66, 0x52, 0xa2, 0x2f, 0x21, 0x3e, 0x96, 0xcb, 0x2e, 0x5d,
	0x4a, 0xfb, 0x22, 0x92, 0xd3, 0x3f, 0x1c, 0xb5, 0xb8, 0x70, 0x37, 0xdf, 0xe1, 0xf7, 0xcd, 0x30,
	0xf3, 0x1d, 0x28, 0x65, 0xe4, 0x8c, 0x12, 0x9e, 0x72, 0xd4, 0x32, 0x32, 0x8d, 0x84, 0xa5, 0x0b,
	0x69, 0x9f, 0x40, 0xb9, 0xfd, 0xe0, 0x0f, 0xee, 0xe2, 0x80, 0x79, 0x6c, 0x8c, 0x08, 0x85, 0xc9,
	0x24, 0xec, 0xd7, 0xd5, 0xff, 0xea, 0xae, 0xe1, 0x89, 0x1a, 0xff, 0x41, 0x91, 0x18, 0xd1, 0x6d,
	0xd8, 0xaf, 0x6b, 0xe2, 0x59, 0xcf, 0x65, 0xa7, 0x6f, 0x37, 0x40, 0xef, 0x52, 0x90, 0xdb, 0x24,
	0x44, 0x95, 0x11, 0xac, 0x43, 0xd1, 0xe7, 0x71, 0xca, 0xe2, 0x54, 0x78, 0x2b, 0xde, 0x4a, 0xda,
	0x3b, 0x60, 0x34, 0xa3, 0x68, 0xe9, 0x97, 0x30, 0xf5, 0x23, 0xd6, 0x84, 0xca, 0x69, 0xc4, 0x89,
	0x5d, 0x11, 0x4b, 0x7e, 0x38, 0x69, 0x1f, 0x6a, 0x1d, 0xba, 0x64, 0x44, 0xe7, 0x71, 0x14, 0xc6,
	0xec, 0xbb, 0x2e, 0x87, 0x4f, 0x1a, 0x68, 0xd7, 0x84, 0x36, 0x14, 0x2e, 0xc2, 0x38, 0xc0, 0xb2,
	0x93, 0x5f, 0xea, 0x8c, 0x37, 0x93, 0x80, 0x4c, 0x59, 0xd8, 0x0a, 0x1e, 0x43, 0x45, 0x6e, 0x8b,
	0x7f, 0x9d, 0x8c, 0x9c, 0x4f, 0x83, 0xcc, 0xaa, 0xf0, 0xb4, 0x38, 0x8f, 0x3c, 0x46, 0x23, 0x5b,
	0x41, 0x17, 0x8c, 0xf5, 0x3e, 0xf8, 0x27, 0xb7, 0xc8, 0xeb, 0x99, 0xbf, 0x05, 0xdf, 0x1e, 0x8e,
	0xd2, 0xc7, 0xa5, 0xe1, 0x00, 0x4a, 0xab, 0x80, 0xb0, 0x96, 0xf3, 0x52, 0x5c, 0x1b, 0xf0, 0x6d,
	0xf8, 0xd5, 0xa5, 0x00, 0x21, 0x27, 0x17, 0xc7, 0xdd, 0x00, 0xed, 0x81, 0xbe, 0xb8, 0x3d, 0x56,
	0x73, 0x6e, 0x9d, 0xc3, 0x57, 0xb4, 0xd5, 0x78, 0x99, 0x59, 0xea, 0x74, 0x66, 0xa9, 0x6f, 0x33,
	0x4b, 0x7d, 0x9e, 0x5b, 0xca, 0x74, 0x6e, 0x29, 0xaf, 0x73, 0x4b, 0xb9, 0xd9, 0x0a, 0xc2, 0x74,
	0x30, 0xe9, 0x39, 0x3e, 0x1f, 0xba, 0x63, 0xe2, 0xfe, 0xbd, 0x3b, 0x0e, 0x87, 0x6e, 0x14, 0xf6,
	0x5c, 0xf1, 0xb3, 0xdc, 0x8c, 0x7a, 0xba, 0xa8, 0x8e, 0xde, 0x03, 0x00, 0x00, 0xff, 0xff, 0xb2,
	0xff, 0x67, 0x20, 0x7e, 0x02, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// WsClient is the client API for Ws service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type WsClient interface {
	Ping(ctx context.Context, in *ret.NoArgs, opts ...grpc.CallOption) (*ret.NoArgs, error)
	// 用户是否在线
	IsSessOnline(ctx context.Context, in *IsSessOnlineReq, opts ...grpc.CallOption) (*ret.BoolResp, error)
	// 关闭用户
	CloseUser(ctx context.Context, in *CloseUserReq, opts ...grpc.CallOption) (*ret.EmptyResp, error)
	// 交换令牌
	Exchange(ctx context.Context, in *ExchangeReq, opts ...grpc.CallOption) (*ret.EmptyResp, error)
	Msg(ctx context.Context, in *MsgReq, opts ...grpc.CallOption) (*ret.EmptyResp, error)
	AllMsg(ctx context.Context, in *AllMsgReq, opts ...grpc.CallOption) (*ret.EmptyResp, error)
}

type wsClient struct {
	cc *grpc.ClientConn
}

func NewWsClient(cc *grpc.ClientConn) WsClient {
	return &wsClient{cc}
}

func (c *wsClient) Ping(ctx context.Context, in *ret.NoArgs, opts ...grpc.CallOption) (*ret.NoArgs, error) {
	out := new(ret.NoArgs)
	err := c.cc.Invoke(ctx, "/ws.Ws/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wsClient) IsSessOnline(ctx context.Context, in *IsSessOnlineReq, opts ...grpc.CallOption) (*ret.BoolResp, error) {
	out := new(ret.BoolResp)
	err := c.cc.Invoke(ctx, "/ws.Ws/IsSessOnline", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wsClient) CloseUser(ctx context.Context, in *CloseUserReq, opts ...grpc.CallOption) (*ret.EmptyResp, error) {
	out := new(ret.EmptyResp)
	err := c.cc.Invoke(ctx, "/ws.Ws/CloseUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wsClient) Exchange(ctx context.Context, in *ExchangeReq, opts ...grpc.CallOption) (*ret.EmptyResp, error) {
	out := new(ret.EmptyResp)
	err := c.cc.Invoke(ctx, "/ws.Ws/Exchange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wsClient) Msg(ctx context.Context, in *MsgReq, opts ...grpc.CallOption) (*ret.EmptyResp, error) {
	out := new(ret.EmptyResp)
	err := c.cc.Invoke(ctx, "/ws.Ws/Msg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wsClient) AllMsg(ctx context.Context, in *AllMsgReq, opts ...grpc.CallOption) (*ret.EmptyResp, error) {
	out := new(ret.EmptyResp)
	err := c.cc.Invoke(ctx, "/ws.Ws/AllMsg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WsServer is the server API for Ws service.
type WsServer interface {
	Ping(context.Context, *ret.NoArgs) (*ret.NoArgs, error)
	// 用户是否在线
	IsSessOnline(context.Context, *IsSessOnlineReq) (*ret.BoolResp, error)
	// 关闭用户
	CloseUser(context.Context, *CloseUserReq) (*ret.EmptyResp, error)
	// 交换令牌
	Exchange(context.Context, *ExchangeReq) (*ret.EmptyResp, error)
	Msg(context.Context, *MsgReq) (*ret.EmptyResp, error)
	AllMsg(context.Context, *AllMsgReq) (*ret.EmptyResp, error)
}

// UnimplementedWsServer can be embedded to have forward compatible implementations.
type UnimplementedWsServer struct {
}

func (*UnimplementedWsServer) Ping(ctx context.Context, req *ret.NoArgs) (*ret.NoArgs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedWsServer) IsSessOnline(ctx context.Context, req *IsSessOnlineReq) (*ret.BoolResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsSessOnline not implemented")
}
func (*UnimplementedWsServer) CloseUser(ctx context.Context, req *CloseUserReq) (*ret.EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloseUser not implemented")
}
func (*UnimplementedWsServer) Exchange(ctx context.Context, req *ExchangeReq) (*ret.EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exchange not implemented")
}
func (*UnimplementedWsServer) Msg(ctx context.Context, req *MsgReq) (*ret.EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Msg not implemented")
}
func (*UnimplementedWsServer) AllMsg(ctx context.Context, req *AllMsgReq) (*ret.EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllMsg not implemented")
}

func RegisterWsServer(s *grpc.Server, srv WsServer) {
	s.RegisterService(&_Ws_serviceDesc, srv)
}

func _Ws_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ret.NoArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WsServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ws.Ws/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WsServer).Ping(ctx, req.(*ret.NoArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ws_IsSessOnline_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IsSessOnlineReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WsServer).IsSessOnline(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ws.Ws/IsSessOnline",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WsServer).IsSessOnline(ctx, req.(*IsSessOnlineReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ws_CloseUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloseUserReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WsServer).CloseUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ws.Ws/CloseUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WsServer).CloseUser(ctx, req.(*CloseUserReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ws_Exchange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExchangeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WsServer).Exchange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ws.Ws/Exchange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WsServer).Exchange(ctx, req.(*ExchangeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ws_Msg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WsServer).Msg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ws.Ws/Msg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WsServer).Msg(ctx, req.(*MsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Ws_AllMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AllMsgReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WsServer).AllMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/ws.Ws/AllMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WsServer).AllMsg(ctx, req.(*AllMsgReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Ws_serviceDesc = grpc.ServiceDesc{
	ServiceName: "ws.Ws",
	HandlerType: (*WsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Ws_Ping_Handler,
		},
		{
			MethodName: "IsSessOnline",
			Handler:    _Ws_IsSessOnline_Handler,
		},
		{
			MethodName: "CloseUser",
			Handler:    _Ws_CloseUser_Handler,
		},
		{
			MethodName: "Exchange",
			Handler:    _Ws_Exchange_Handler,
		},
		{
			MethodName: "Msg",
			Handler:    _Ws_Msg_Handler,
		},
		{
			MethodName: "AllMsg",
			Handler:    _Ws_AllMsg_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "ws.proto",
}

func (m *ExchangeReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExchangeReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExchangeReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SessId) > 0 {
		i -= len(m.SessId)
		copy(dAtA[i:], m.SessId)
		i = encodeVarintWs(dAtA, i, uint64(len(m.SessId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Uuid) > 0 {
		i -= len(m.Uuid)
		copy(dAtA[i:], m.Uuid)
		i = encodeVarintWs(dAtA, i, uint64(len(m.Uuid)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintWs(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessId) > 0 {
		i -= len(m.SessId)
		copy(dAtA[i:], m.SessId)
		i = encodeVarintWs(dAtA, i, uint64(len(m.SessId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AllMsgReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllMsgReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllMsgReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintWs(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CloseUserReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CloseUserReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CloseUserReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		i -= len(m.Content)
		copy(dAtA[i:], m.Content)
		i = encodeVarintWs(dAtA, i, uint64(len(m.Content)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.SessId) > 0 {
		i -= len(m.SessId)
		copy(dAtA[i:], m.SessId)
		i = encodeVarintWs(dAtA, i, uint64(len(m.SessId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *IsSessOnlineReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IsSessOnlineReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IsSessOnlineReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SessId) > 0 {
		i -= len(m.SessId)
		copy(dAtA[i:], m.SessId)
		i = encodeVarintWs(dAtA, i, uint64(len(m.SessId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintWs(dAtA []byte, offset int, v uint64) int {
	offset -= sovWs(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ExchangeReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Uuid)
	if l > 0 {
		n += 1 + l + sovWs(uint64(l))
	}
	l = len(m.SessId)
	if l > 0 {
		n += 1 + l + sovWs(uint64(l))
	}
	return n
}

func (m *MsgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessId)
	if l > 0 {
		n += 1 + l + sovWs(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovWs(uint64(l))
	}
	return n
}

func (m *AllMsgReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovWs(uint64(l))
	}
	return n
}

func (m *CloseUserReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessId)
	if l > 0 {
		n += 1 + l + sovWs(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovWs(uint64(l))
	}
	return n
}

func (m *IsSessOnlineReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.SessId)
	if l > 0 {
		n += 1 + l + sovWs(uint64(l))
	}
	return n
}

func sovWs(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozWs(x uint64) (n int) {
	return sovWs(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ExchangeReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExchangeReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExchangeReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uuid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllMsgReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllMsgReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllMsgReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CloseUserReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CloseUserReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CloseUserReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthWs
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthWs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IsSessOnlineReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowWs
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IsSessOnlineReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IsSessOnlineReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowWs
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthWs
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthWs
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SessId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipWs(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthWs
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthWs
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipWs(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowWs
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowWs
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthWs
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupWs
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthWs
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthWs        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowWs          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupWs = fmt.Errorf("proto: unexpected end of group")
)
