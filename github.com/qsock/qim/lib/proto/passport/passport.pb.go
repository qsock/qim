// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: passport.proto

package passport

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	errmsg "github.com/qsock/qim/lib/proto/errmsg"
	model "github.com/qsock/qim/lib/proto/model"
	ret "github.com/qsock/qim/lib/proto/ret"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type LoginResp struct {
	Err *errmsg.ErrMsg `protobuf:"bytes,1,opt,name=err,proto3" json:"err,omitempty"`
	// 用户auth信息
	Auth *model.UserAuth `protobuf:"bytes,2,opt,name=auth,proto3" json:"auth,omitempty"`
}

func (m *LoginResp) Reset()         { *m = LoginResp{} }
func (m *LoginResp) String() string { return proto.CompactTextString(m) }
func (*LoginResp) ProtoMessage()    {}
func (*LoginResp) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{0}
}
func (m *LoginResp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LoginResp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LoginResp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LoginResp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LoginResp.Merge(m, src)
}
func (m *LoginResp) XXX_Size() int {
	return m.Size()
}
func (m *LoginResp) XXX_DiscardUnknown() {
	xxx_messageInfo_LoginResp.DiscardUnknown(m)
}

var xxx_messageInfo_LoginResp proto.InternalMessageInfo

func (m *LoginResp) GetErr() *errmsg.ErrMsg {
	if m != nil {
		return m.Err
	}
	return nil
}

func (m *LoginResp) GetAuth() *model.UserAuth {
	if m != nil {
		return m.Auth
	}
	return nil
}

type SmsReq struct {
	// 手机号
	Tel string `protobuf:"bytes,1,opt,name=tel,proto3" json:"tel,omitempty"`
}

func (m *SmsReq) Reset()         { *m = SmsReq{} }
func (m *SmsReq) String() string { return proto.CompactTextString(m) }
func (*SmsReq) ProtoMessage()    {}
func (*SmsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{1}
}
func (m *SmsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SmsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SmsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SmsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SmsReq.Merge(m, src)
}
func (m *SmsReq) XXX_Size() int {
	return m.Size()
}
func (m *SmsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SmsReq.DiscardUnknown(m)
}

var xxx_messageInfo_SmsReq proto.InternalMessageInfo

func (m *SmsReq) GetTel() string {
	if m != nil {
		return m.Tel
	}
	return ""
}

type SmsModel struct {
	// 验证码
	Code string `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	// 创建时间
	CreatedOn int64 `protobuf:"varint,2,opt,name=created_on,json=createdOn,proto3" json:"created_on,omitempty"`
}

func (m *SmsModel) Reset()         { *m = SmsModel{} }
func (m *SmsModel) String() string { return proto.CompactTextString(m) }
func (*SmsModel) ProtoMessage()    {}
func (*SmsModel) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{2}
}
func (m *SmsModel) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SmsModel) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SmsModel.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SmsModel) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SmsModel.Merge(m, src)
}
func (m *SmsModel) XXX_Size() int {
	return m.Size()
}
func (m *SmsModel) XXX_DiscardUnknown() {
	xxx_messageInfo_SmsModel.DiscardUnknown(m)
}

var xxx_messageInfo_SmsModel proto.InternalMessageInfo

func (m *SmsModel) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *SmsModel) GetCreatedOn() int64 {
	if m != nil {
		return m.CreatedOn
	}
	return 0
}

// 手机短信登陆
type TelLoginReq struct {
	//  忽略
	Meta *model.RequestMeta `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// 手机号
	Tel string `protobuf:"bytes,2,opt,name=tel,proto3" json:"tel,omitempty"`
	// 验证码
	Code string `protobuf:"bytes,3,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *TelLoginReq) Reset()         { *m = TelLoginReq{} }
func (m *TelLoginReq) String() string { return proto.CompactTextString(m) }
func (*TelLoginReq) ProtoMessage()    {}
func (*TelLoginReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{3}
}
func (m *TelLoginReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TelLoginReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TelLoginReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TelLoginReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TelLoginReq.Merge(m, src)
}
func (m *TelLoginReq) XXX_Size() int {
	return m.Size()
}
func (m *TelLoginReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TelLoginReq.DiscardUnknown(m)
}

var xxx_messageInfo_TelLoginReq proto.InternalMessageInfo

func (m *TelLoginReq) GetMeta() *model.RequestMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *TelLoginReq) GetTel() string {
	if m != nil {
		return m.Tel
	}
	return ""
}

func (m *TelLoginReq) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

// qq登陆
type QqloginReq struct {
	//  忽略
	Meta *model.RequestMeta `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// qq返回的accesstoken
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	// qq返回的openid
	Openid string `protobuf:"bytes,3,opt,name=openid,proto3" json:"openid,omitempty"`
}

func (m *QqloginReq) Reset()         { *m = QqloginReq{} }
func (m *QqloginReq) String() string { return proto.CompactTextString(m) }
func (*QqloginReq) ProtoMessage()    {}
func (*QqloginReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{4}
}
func (m *QqloginReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QqloginReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QqloginReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QqloginReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QqloginReq.Merge(m, src)
}
func (m *QqloginReq) XXX_Size() int {
	return m.Size()
}
func (m *QqloginReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QqloginReq.DiscardUnknown(m)
}

var xxx_messageInfo_QqloginReq proto.InternalMessageInfo

func (m *QqloginReq) GetMeta() *model.RequestMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *QqloginReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *QqloginReq) GetOpenid() string {
	if m != nil {
		return m.Openid
	}
	return ""
}

// 微信登陆
type WxLoginReq struct {
	//  忽略
	Meta *model.RequestMeta `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	// 微信登陆的code
	Code string `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
}

func (m *WxLoginReq) Reset()         { *m = WxLoginReq{} }
func (m *WxLoginReq) String() string { return proto.CompactTextString(m) }
func (*WxLoginReq) ProtoMessage()    {}
func (*WxLoginReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{5}
}
func (m *WxLoginReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WxLoginReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WxLoginReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WxLoginReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WxLoginReq.Merge(m, src)
}
func (m *WxLoginReq) XXX_Size() int {
	return m.Size()
}
func (m *WxLoginReq) XXX_DiscardUnknown() {
	xxx_messageInfo_WxLoginReq.DiscardUnknown(m)
}

var xxx_messageInfo_WxLoginReq proto.InternalMessageInfo

func (m *WxLoginReq) GetMeta() *model.RequestMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *WxLoginReq) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

type RefreshReq struct {
	//  忽略
	Meta  *model.RequestMeta `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	Token string             `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	// refresh_token
	RefreshToken string `protobuf:"bytes,3,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
}

func (m *RefreshReq) Reset()         { *m = RefreshReq{} }
func (m *RefreshReq) String() string { return proto.CompactTextString(m) }
func (*RefreshReq) ProtoMessage()    {}
func (*RefreshReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{6}
}
func (m *RefreshReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RefreshReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RefreshReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RefreshReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RefreshReq.Merge(m, src)
}
func (m *RefreshReq) XXX_Size() int {
	return m.Size()
}
func (m *RefreshReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RefreshReq.DiscardUnknown(m)
}

var xxx_messageInfo_RefreshReq proto.InternalMessageInfo

func (m *RefreshReq) GetMeta() *model.RequestMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *RefreshReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *RefreshReq) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

type LogoutReq struct {
	//  忽略
	Meta *model.RequestMeta `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
}

func (m *LogoutReq) Reset()         { *m = LogoutReq{} }
func (m *LogoutReq) String() string { return proto.CompactTextString(m) }
func (*LogoutReq) ProtoMessage()    {}
func (*LogoutReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{7}
}
func (m *LogoutReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogoutReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogoutReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogoutReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogoutReq.Merge(m, src)
}
func (m *LogoutReq) XXX_Size() int {
	return m.Size()
}
func (m *LogoutReq) XXX_DiscardUnknown() {
	xxx_messageInfo_LogoutReq.DiscardUnknown(m)
}

var xxx_messageInfo_LogoutReq proto.InternalMessageInfo

func (m *LogoutReq) GetMeta() *model.RequestMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

type AuthReq struct {
	Meta  *model.RequestMeta `protobuf:"bytes,1,opt,name=meta,proto3" json:"meta,omitempty"`
	Token string             `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
}

func (m *AuthReq) Reset()         { *m = AuthReq{} }
func (m *AuthReq) String() string { return proto.CompactTextString(m) }
func (*AuthReq) ProtoMessage()    {}
func (*AuthReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{8}
}
func (m *AuthReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthReq.Merge(m, src)
}
func (m *AuthReq) XXX_Size() int {
	return m.Size()
}
func (m *AuthReq) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthReq.DiscardUnknown(m)
}

var xxx_messageInfo_AuthReq proto.InternalMessageInfo

func (m *AuthReq) GetMeta() *model.RequestMeta {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *AuthReq) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type JwtClaims struct {
	Device model.Device `protobuf:"varint,1,opt,name=device,proto3,enum=model.Device" json:"device,omitempty"`
	UserId int64        `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	UserIp string       `protobuf:"bytes,3,opt,name=user_ip,json=userIp,proto3" json:"user_ip,omitempty"`
	SeqId  int64        `protobuf:"varint,4,opt,name=seq_id,json=seqId,proto3" json:"seq_id,omitempty"`
}

func (m *JwtClaims) Reset()         { *m = JwtClaims{} }
func (m *JwtClaims) String() string { return proto.CompactTextString(m) }
func (*JwtClaims) ProtoMessage()    {}
func (*JwtClaims) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{9}
}
func (m *JwtClaims) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *JwtClaims) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_JwtClaims.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *JwtClaims) XXX_Merge(src proto.Message) {
	xxx_messageInfo_JwtClaims.Merge(m, src)
}
func (m *JwtClaims) XXX_Size() int {
	return m.Size()
}
func (m *JwtClaims) XXX_DiscardUnknown() {
	xxx_messageInfo_JwtClaims.DiscardUnknown(m)
}

var xxx_messageInfo_JwtClaims proto.InternalMessageInfo

func (m *JwtClaims) GetDevice() model.Device {
	if m != nil {
		return m.Device
	}
	return model.Device_DeviceFalse
}

func (m *JwtClaims) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *JwtClaims) GetUserIp() string {
	if m != nil {
		return m.UserIp
	}
	return ""
}

func (m *JwtClaims) GetSeqId() int64 {
	if m != nil {
		return m.SeqId
	}
	return 0
}

type BanReq struct {
	UserId int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	EndOn  int64 `protobuf:"varint,2,opt,name=end_on,json=endOn,proto3" json:"end_on,omitempty"`
}

func (m *BanReq) Reset()         { *m = BanReq{} }
func (m *BanReq) String() string { return proto.CompactTextString(m) }
func (*BanReq) ProtoMessage()    {}
func (*BanReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{10}
}
func (m *BanReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BanReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BanReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BanReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BanReq.Merge(m, src)
}
func (m *BanReq) XXX_Size() int {
	return m.Size()
}
func (m *BanReq) XXX_DiscardUnknown() {
	xxx_messageInfo_BanReq.DiscardUnknown(m)
}

var xxx_messageInfo_BanReq proto.InternalMessageInfo

func (m *BanReq) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *BanReq) GetEndOn() int64 {
	if m != nil {
		return m.EndOn
	}
	return 0
}

type UnBanReq struct {
	UserId int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *UnBanReq) Reset()         { *m = UnBanReq{} }
func (m *UnBanReq) String() string { return proto.CompactTextString(m) }
func (*UnBanReq) ProtoMessage()    {}
func (*UnBanReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_4affa6d033a78188, []int{11}
}
func (m *UnBanReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnBanReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnBanReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnBanReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnBanReq.Merge(m, src)
}
func (m *UnBanReq) XXX_Size() int {
	return m.Size()
}
func (m *UnBanReq) XXX_DiscardUnknown() {
	xxx_messageInfo_UnBanReq.DiscardUnknown(m)
}

var xxx_messageInfo_UnBanReq proto.InternalMessageInfo

func (m *UnBanReq) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func init() {
	proto.RegisterType((*LoginResp)(nil), "passport.LoginResp")
	proto.RegisterType((*SmsReq)(nil), "passport.SmsReq")
	proto.RegisterType((*SmsModel)(nil), "passport.SmsModel")
	proto.RegisterType((*TelLoginReq)(nil), "passport.TelLoginReq")
	proto.RegisterType((*QqloginReq)(nil), "passport.QqloginReq")
	proto.RegisterType((*WxLoginReq)(nil), "passport.WxLoginReq")
	proto.RegisterType((*RefreshReq)(nil), "passport.RefreshReq")
	proto.RegisterType((*LogoutReq)(nil), "passport.LogoutReq")
	proto.RegisterType((*AuthReq)(nil), "passport.AuthReq")
	proto.RegisterType((*JwtClaims)(nil), "passport.JwtClaims")
	proto.RegisterType((*BanReq)(nil), "passport.BanReq")
	proto.RegisterType((*UnBanReq)(nil), "passport.UnBanReq")
}

func init() { proto.RegisterFile("passport.proto", fileDescriptor_4affa6d033a78188) }

var fileDescriptor_4affa6d033a78188 = []byte{
	// 658 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x54, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0x4d, 0xea, 0xc4, 0x49, 0x6e, 0xda, 0xb4, 0x0c, 0x2d, 0x54, 0x96, 0x88, 0xaa, 0xa9, 0x78,
	0x74, 0x41, 0x22, 0xa5, 0x12, 0xea, 0x86, 0x45, 0x0b, 0x15, 0x14, 0x51, 0x28, 0x4e, 0x2b, 0x24,
	0x58, 0x54, 0x4e, 0x7c, 0x71, 0xac, 0xc6, 0x1e, 0x7b, 0x66, 0xcc, 0x43, 0xfc, 0x04, 0x9f, 0xc5,
	0xb2, 0x4b, 0x96, 0xa8, 0x5d, 0xf3, 0x0f, 0xc8, 0xe3, 0x71, 0xec, 0x8a, 0x02, 0xaa, 0xba, 0xf3,
	0x7d, 0x9d, 0x7b, 0xec, 0x7b, 0x8e, 0xa1, 0x13, 0x39, 0x42, 0x44, 0x8c, 0xcb, 0x5e, 0xc4, 0x99,
	0x64, 0xa4, 0x99, 0xc7, 0x56, 0x8b, 0xa3, 0x4e, 0x5a, 0xed, 0x80, 0xb9, 0x38, 0xd5, 0xc1, 0x3c,
	0x72, 0x1e, 0x08, 0x2f, 0x8b, 0xa8, 0x0d, 0xad, 0x97, 0xcc, 0xf3, 0x43, 0x1b, 0x45, 0x44, 0xd6,
	0xc0, 0x40, 0xce, 0x57, 0xab, 0x6b, 0xd5, 0x07, 0xed, 0x41, 0xa7, 0xa7, 0x1b, 0x77, 0x39, 0xdf,
	0x17, 0x9e, 0x9d, 0x96, 0xc8, 0x3a, 0xd4, 0x9c, 0x44, 0x4e, 0x56, 0xe7, 0x54, 0xcb, 0x62, 0x2f,
	0x03, 0x3e, 0x12, 0xc8, 0xb7, 0x13, 0x39, 0xb1, 0x55, 0x91, 0x5a, 0x60, 0x0e, 0x03, 0x61, 0x63,
	0x4c, 0x96, 0xc0, 0x90, 0x38, 0x55, 0x80, 0x2d, 0x3b, 0x7d, 0xa4, 0x8f, 0xa1, 0x39, 0x0c, 0xc4,
	0x7e, 0x3a, 0x46, 0x08, 0xd4, 0xc6, 0xcc, 0x45, 0x5d, 0x56, 0xcf, 0xe4, 0x0e, 0xc0, 0x98, 0xa3,
	0x23, 0xd1, 0x3d, 0x66, 0xa1, 0x5a, 0x63, 0xd8, 0x2d, 0x9d, 0x79, 0x1d, 0xd2, 0xf7, 0xd0, 0x3e,
	0xc4, 0xa9, 0x66, 0x1c, 0x93, 0x7b, 0x50, 0x0b, 0x50, 0x3a, 0x9a, 0x31, 0xd1, 0x74, 0x6c, 0x8c,
	0x13, 0x14, 0x72, 0x1f, 0xa5, 0x63, 0xab, 0x7a, 0xce, 0x63, 0x6e, 0xc6, 0x63, 0xb6, 0xdb, 0x28,
	0x76, 0xd3, 0x11, 0xc0, 0x9b, 0x78, 0x7a, 0x55, 0xec, 0x65, 0xa8, 0x4b, 0x76, 0x82, 0xa1, 0x46,
	0xcf, 0x02, 0x72, 0x0b, 0x4c, 0x16, 0x61, 0xe8, 0xbb, 0x7a, 0x83, 0x8e, 0xe8, 0x73, 0x80, 0xb7,
	0x9f, 0xaf, 0xcc, 0x3f, 0x67, 0x3b, 0x57, 0x62, 0xcb, 0x00, 0x6c, 0xfc, 0xc0, 0x51, 0x4c, 0xae,
	0xcf, 0x76, 0x1d, 0x16, 0x78, 0x86, 0x75, 0x9c, 0x55, 0x33, 0xd2, 0xf3, 0x3a, 0x79, 0x98, 0xe6,
	0xe8, 0xa6, 0x92, 0x0a, 0x4b, 0xe4, 0x15, 0xf6, 0xd1, 0x67, 0xd0, 0x50, 0xca, 0xb8, 0x2e, 0x45,
	0xfa, 0x15, 0x5a, 0x2f, 0x3e, 0xc9, 0x27, 0x53, 0xc7, 0x0f, 0x04, 0xb9, 0x0b, 0xa6, 0x8b, 0x1f,
	0xfd, 0x71, 0xa6, 0x9d, 0xce, 0x60, 0x41, 0x83, 0x3d, 0x55, 0x49, 0x5b, 0x17, 0xc9, 0x6d, 0x68,
	0x24, 0x02, 0xf9, 0xb1, 0xef, 0x6a, 0x25, 0x99, 0x69, 0xb8, 0xe7, 0x16, 0x85, 0x28, 0x3f, 0x8f,
	0x2a, 0x44, 0x64, 0x05, 0x4c, 0x81, 0x71, 0x3a, 0x50, 0x53, 0x03, 0x75, 0x81, 0xf1, 0x9e, 0x4b,
	0xb7, 0xc0, 0xdc, 0x71, 0xd4, 0xc5, 0x4a, 0x90, 0xd5, 0x0b, 0x90, 0x2b, 0x60, 0x62, 0x58, 0x12,
	0x6d, 0x1d, 0xc3, 0x54, 0xb0, 0xeb, 0xd0, 0x3c, 0x0a, 0xff, 0x33, 0x3b, 0xf8, 0x65, 0x40, 0xf3,
	0x40, 0xfb, 0x96, 0x50, 0xa8, 0x1d, 0xf8, 0xa1, 0x47, 0xda, 0xbd, 0xd4, 0xc0, 0xaf, 0xd8, 0x36,
	0xf7, 0x84, 0x55, 0x0e, 0x68, 0x85, 0x6c, 0x80, 0x31, 0x0c, 0x04, 0x59, 0xea, 0xcd, 0xdc, 0x9f,
	0x19, 0xce, 0xea, 0xa8, 0xbe, 0xdd, 0x20, 0x92, 0x5f, 0x52, 0x47, 0xd3, 0x0a, 0xd9, 0x82, 0x66,
	0xee, 0x18, 0xb2, 0x52, 0xf4, 0x97, 0x5c, 0x64, 0xdd, 0x2c, 0xd2, 0xb3, 0x7f, 0x01, 0xad, 0x90,
	0x47, 0xd0, 0xd0, 0x76, 0x20, 0xcb, 0x45, 0x47, 0xe1, 0x90, 0x7f, 0xcc, 0x69, 0x89, 0x97, 0xe7,
	0x0a, 0xd5, 0xff, 0x6d, 0x6e, 0x03, 0x6a, 0xa9, 0x54, 0xc8, 0x8d, 0xa2, 0xac, 0xa5, 0x63, 0xcd,
	0xab, 0xd7, 0xda, 0x0b, 0xa5, 0x6e, 0x1d, 0x40, 0x43, 0x6b, 0xbf, 0xbc, 0xa2, 0xb0, 0x83, 0xb5,
	0xa8, 0x06, 0x86, 0x92, 0xfb, 0xa1, 0xa7, 0x67, 0xfa, 0x60, 0x66, 0xf2, 0x25, 0x17, 0xf7, 0x67,
	0x82, 0xbe, 0xe4, 0xcb, 0x6d, 0x80, 0xb1, 0xe3, 0x84, 0xe5, 0x8f, 0x9c, 0xdd, 0xf1, 0x92, 0xd6,
	0x87, 0x50, 0x57, 0x57, 0x26, 0xa4, 0x68, 0xce, 0xcf, 0xfe, 0x67, 0xfb, 0xce, 0xf6, 0xf7, 0xb3,
	0x6e, 0xf5, 0xf4, 0xac, 0x5b, 0xfd, 0x79, 0xd6, 0xad, 0x7e, 0x3b, 0xef, 0x56, 0x4e, 0xcf, 0xbb,
	0x95, 0x1f, 0xe7, 0xdd, 0xca, 0xbb, 0xfb, 0x9e, 0x2f, 0x27, 0xc9, 0xa8, 0x37, 0x66, 0x41, 0x3f,
	0x16, 0x6c, 0x7c, 0xd2, 0x8f, 0xfd, 0xa0, 0x3f, 0xf5, 0x47, 0x7d, 0xf5, 0xbb, 0xee, 0xe7, 0xe8,
	0x23, 0x53, 0xc5, 0x9b, 0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0xf3, 0x05, 0xbe, 0x6f, 0x00, 0x06,
	0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// PassportClient is the client API for Passport service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type PassportClient interface {
	Ping(ctx context.Context, in *ret.NoArgs, opts ...grpc.CallOption) (*ret.NoArgs, error)
	// 发送手机短信
	Sms(ctx context.Context, in *SmsReq, opts ...grpc.CallOption) (*ret.EmptyResp, error)
	TelLogin(ctx context.Context, in *TelLoginReq, opts ...grpc.CallOption) (*LoginResp, error)
	Qqlogin(ctx context.Context, in *QqloginReq, opts ...grpc.CallOption) (*LoginResp, error)
	WxLogin(ctx context.Context, in *WxLoginReq, opts ...grpc.CallOption) (*LoginResp, error)
	// 鉴权
	Auth(ctx context.Context, in *AuthReq, opts ...grpc.CallOption) (*ret.IntResp, error)
	Refresh(ctx context.Context, in *RefreshReq, opts ...grpc.CallOption) (*ret.StringResp, error)
	Logout(ctx context.Context, in *LogoutReq, opts ...grpc.CallOption) (*ret.EmptyResp, error)
	Ban(ctx context.Context, in *BanReq, opts ...grpc.CallOption) (*ret.EmptyResp, error)
	UnBan(ctx context.Context, in *UnBanReq, opts ...grpc.CallOption) (*ret.EmptyResp, error)
}

type passportClient struct {
	cc *grpc.ClientConn
}

func NewPassportClient(cc *grpc.ClientConn) PassportClient {
	return &passportClient{cc}
}

func (c *passportClient) Ping(ctx context.Context, in *ret.NoArgs, opts ...grpc.CallOption) (*ret.NoArgs, error) {
	out := new(ret.NoArgs)
	err := c.cc.Invoke(ctx, "/passport.Passport/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passportClient) Sms(ctx context.Context, in *SmsReq, opts ...grpc.CallOption) (*ret.EmptyResp, error) {
	out := new(ret.EmptyResp)
	err := c.cc.Invoke(ctx, "/passport.Passport/Sms", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passportClient) TelLogin(ctx context.Context, in *TelLoginReq, opts ...grpc.CallOption) (*LoginResp, error) {
	out := new(LoginResp)
	err := c.cc.Invoke(ctx, "/passport.Passport/TelLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passportClient) Qqlogin(ctx context.Context, in *QqloginReq, opts ...grpc.CallOption) (*LoginResp, error) {
	out := new(LoginResp)
	err := c.cc.Invoke(ctx, "/passport.Passport/Qqlogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passportClient) WxLogin(ctx context.Context, in *WxLoginReq, opts ...grpc.CallOption) (*LoginResp, error) {
	out := new(LoginResp)
	err := c.cc.Invoke(ctx, "/passport.Passport/WxLogin", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passportClient) Auth(ctx context.Context, in *AuthReq, opts ...grpc.CallOption) (*ret.IntResp, error) {
	out := new(ret.IntResp)
	err := c.cc.Invoke(ctx, "/passport.Passport/Auth", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passportClient) Refresh(ctx context.Context, in *RefreshReq, opts ...grpc.CallOption) (*ret.StringResp, error) {
	out := new(ret.StringResp)
	err := c.cc.Invoke(ctx, "/passport.Passport/Refresh", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passportClient) Logout(ctx context.Context, in *LogoutReq, opts ...grpc.CallOption) (*ret.EmptyResp, error) {
	out := new(ret.EmptyResp)
	err := c.cc.Invoke(ctx, "/passport.Passport/Logout", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passportClient) Ban(ctx context.Context, in *BanReq, opts ...grpc.CallOption) (*ret.EmptyResp, error) {
	out := new(ret.EmptyResp)
	err := c.cc.Invoke(ctx, "/passport.Passport/Ban", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *passportClient) UnBan(ctx context.Context, in *UnBanReq, opts ...grpc.CallOption) (*ret.EmptyResp, error) {
	out := new(ret.EmptyResp)
	err := c.cc.Invoke(ctx, "/passport.Passport/UnBan", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PassportServer is the server API for Passport service.
type PassportServer interface {
	Ping(context.Context, *ret.NoArgs) (*ret.NoArgs, error)
	// 发送手机短信
	Sms(context.Context, *SmsReq) (*ret.EmptyResp, error)
	TelLogin(context.Context, *TelLoginReq) (*LoginResp, error)
	Qqlogin(context.Context, *QqloginReq) (*LoginResp, error)
	WxLogin(context.Context, *WxLoginReq) (*LoginResp, error)
	// 鉴权
	Auth(context.Context, *AuthReq) (*ret.IntResp, error)
	Refresh(context.Context, *RefreshReq) (*ret.StringResp, error)
	Logout(context.Context, *LogoutReq) (*ret.EmptyResp, error)
	Ban(context.Context, *BanReq) (*ret.EmptyResp, error)
	UnBan(context.Context, *UnBanReq) (*ret.EmptyResp, error)
}

// UnimplementedPassportServer can be embedded to have forward compatible implementations.
type UnimplementedPassportServer struct {
}

func (*UnimplementedPassportServer) Ping(ctx context.Context, req *ret.NoArgs) (*ret.NoArgs, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ping not implemented")
}
func (*UnimplementedPassportServer) Sms(ctx context.Context, req *SmsReq) (*ret.EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sms not implemented")
}
func (*UnimplementedPassportServer) TelLogin(ctx context.Context, req *TelLoginReq) (*LoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TelLogin not implemented")
}
func (*UnimplementedPassportServer) Qqlogin(ctx context.Context, req *QqloginReq) (*LoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Qqlogin not implemented")
}
func (*UnimplementedPassportServer) WxLogin(ctx context.Context, req *WxLoginReq) (*LoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WxLogin not implemented")
}
func (*UnimplementedPassportServer) Auth(ctx context.Context, req *AuthReq) (*ret.IntResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Auth not implemented")
}
func (*UnimplementedPassportServer) Refresh(ctx context.Context, req *RefreshReq) (*ret.StringResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Refresh not implemented")
}
func (*UnimplementedPassportServer) Logout(ctx context.Context, req *LogoutReq) (*ret.EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Logout not implemented")
}
func (*UnimplementedPassportServer) Ban(ctx context.Context, req *BanReq) (*ret.EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Ban not implemented")
}
func (*UnimplementedPassportServer) UnBan(ctx context.Context, req *UnBanReq) (*ret.EmptyResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnBan not implemented")
}

func RegisterPassportServer(s *grpc.Server, srv PassportServer) {
	s.RegisterService(&_Passport_serviceDesc, srv)
}

func _Passport_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ret.NoArgs)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassportServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/passport.Passport/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassportServer).Ping(ctx, req.(*ret.NoArgs))
	}
	return interceptor(ctx, in, info, handler)
}

func _Passport_Sms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SmsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassportServer).Sms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/passport.Passport/Sms",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassportServer).Sms(ctx, req.(*SmsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Passport_TelLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TelLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassportServer).TelLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/passport.Passport/TelLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassportServer).TelLogin(ctx, req.(*TelLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Passport_Qqlogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QqloginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassportServer).Qqlogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/passport.Passport/Qqlogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassportServer).Qqlogin(ctx, req.(*QqloginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Passport_WxLogin_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WxLoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassportServer).WxLogin(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/passport.Passport/WxLogin",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassportServer).WxLogin(ctx, req.(*WxLoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Passport_Auth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassportServer).Auth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/passport.Passport/Auth",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassportServer).Auth(ctx, req.(*AuthReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Passport_Refresh_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassportServer).Refresh(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/passport.Passport/Refresh",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassportServer).Refresh(ctx, req.(*RefreshReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Passport_Logout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogoutReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassportServer).Logout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/passport.Passport/Logout",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassportServer).Logout(ctx, req.(*LogoutReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Passport_Ban_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BanReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassportServer).Ban(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/passport.Passport/Ban",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassportServer).Ban(ctx, req.(*BanReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Passport_UnBan_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnBanReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PassportServer).UnBan(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/passport.Passport/UnBan",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PassportServer).UnBan(ctx, req.(*UnBanReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Passport_serviceDesc = grpc.ServiceDesc{
	ServiceName: "passport.Passport",
	HandlerType: (*PassportServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Passport_Ping_Handler,
		},
		{
			MethodName: "Sms",
			Handler:    _Passport_Sms_Handler,
		},
		{
			MethodName: "TelLogin",
			Handler:    _Passport_TelLogin_Handler,
		},
		{
			MethodName: "Qqlogin",
			Handler:    _Passport_Qqlogin_Handler,
		},
		{
			MethodName: "WxLogin",
			Handler:    _Passport_WxLogin_Handler,
		},
		{
			MethodName: "Auth",
			Handler:    _Passport_Auth_Handler,
		},
		{
			MethodName: "Refresh",
			Handler:    _Passport_Refresh_Handler,
		},
		{
			MethodName: "Logout",
			Handler:    _Passport_Logout_Handler,
		},
		{
			MethodName: "Ban",
			Handler:    _Passport_Ban_Handler,
		},
		{
			MethodName: "UnBan",
			Handler:    _Passport_UnBan_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "passport.proto",
}

func (m *LoginResp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LoginResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LoginResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Auth != nil {
		{
			size, err := m.Auth.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Err != nil {
		{
			size, err := m.Err.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SmsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SmsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Tel) > 0 {
		i -= len(m.Tel)
		copy(dAtA[i:], m.Tel)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Tel)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SmsModel) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SmsModel) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SmsModel) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedOn != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.CreatedOn))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TelLoginReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TelLoginReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TelLoginReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Tel) > 0 {
		i -= len(m.Tel)
		copy(dAtA[i:], m.Tel)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Tel)))
		i--
		dAtA[i] = 0x12
	}
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QqloginReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QqloginReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QqloginReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Openid) > 0 {
		i -= len(m.Openid)
		copy(dAtA[i:], m.Openid)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Openid)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WxLoginReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WxLoginReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WxLoginReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RefreshReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RefreshReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RefreshReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *LogoutReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogoutReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogoutReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintPassport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *JwtClaims) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *JwtClaims) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *JwtClaims) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SeqId != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.SeqId))
		i--
		dAtA[i] = 0x20
	}
	if len(m.UserIp) > 0 {
		i -= len(m.UserIp)
		copy(dAtA[i:], m.UserIp)
		i = encodeVarintPassport(dAtA, i, uint64(len(m.UserIp)))
		i--
		dAtA[i] = 0x1a
	}
	if m.UserId != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.Device != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.Device))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BanReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BanReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BanReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.EndOn != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.EndOn))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UnBanReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnBanReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnBanReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		i = encodeVarintPassport(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintPassport(dAtA []byte, offset int, v uint64) int {
	offset -= sovPassport(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *LoginResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Err != nil {
		l = m.Err.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.Auth != nil {
		l = m.Auth.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *SmsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Tel)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *SmsModel) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.CreatedOn != 0 {
		n += 1 + sovPassport(uint64(m.CreatedOn))
	}
	return n
}

func (m *TelLoginReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Tel)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *QqloginReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Openid)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *WxLoginReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *RefreshReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *LogoutReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *AuthReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovPassport(uint64(l))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	return n
}

func (m *JwtClaims) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Device != 0 {
		n += 1 + sovPassport(uint64(m.Device))
	}
	if m.UserId != 0 {
		n += 1 + sovPassport(uint64(m.UserId))
	}
	l = len(m.UserIp)
	if l > 0 {
		n += 1 + l + sovPassport(uint64(l))
	}
	if m.SeqId != 0 {
		n += 1 + sovPassport(uint64(m.SeqId))
	}
	return n
}

func (m *BanReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovPassport(uint64(m.UserId))
	}
	if m.EndOn != 0 {
		n += 1 + sovPassport(uint64(m.EndOn))
	}
	return n
}

func (m *UnBanReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovPassport(uint64(m.UserId))
	}
	return n
}

func sovPassport(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozPassport(x uint64) (n int) {
	return sovPassport(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *LoginResp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LoginResp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LoginResp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Err", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Err == nil {
				m.Err = &errmsg.ErrMsg{}
			}
			if err := m.Err.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Auth", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Auth == nil {
				m.Auth = &model.UserAuth{}
			}
			if err := m.Auth.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SmsModel) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SmsModel: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SmsModel: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOn", wireType)
			}
			m.CreatedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedOn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TelLoginReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TelLoginReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TelLoginReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &model.RequestMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QqloginReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QqloginReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QqloginReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &model.RequestMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Openid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Openid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WxLoginReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WxLoginReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WxLoginReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &model.RequestMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RefreshReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RefreshReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RefreshReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &model.RequestMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogoutReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogoutReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogoutReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &model.RequestMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Meta == nil {
				m.Meta = &model.RequestMeta{}
			}
			if err := m.Meta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *JwtClaims) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: JwtClaims: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: JwtClaims: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			m.Device = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Device |= model.Device(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthPassport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthPassport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqId", wireType)
			}
			m.SeqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BanReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BanReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BanReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOn", wireType)
			}
			m.EndOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EndOn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnBanReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnBanReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnBanReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipPassport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthPassport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipPassport(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowPassport
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowPassport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthPassport
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupPassport
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthPassport
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthPassport        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowPassport          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupPassport = fmt.Errorf("proto: unexpected end of group")
)
