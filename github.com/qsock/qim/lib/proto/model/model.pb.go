// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: model.proto

package model

import (
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Device int32

const (
	Device_DeviceFalse Device = 0
	// mac
	Device_DeviceMac Device = 1
	// win
	Device_DeviceWin Device = 2
	// 安卓
	Device_DeviceAndroid Device = 3
	// ios
	Device_DeviceIos Device = 4
	// web
	Device_DeviceWeb Device = 5
	// 小程序
	Device_DeviceMiniProgram Device = 6
)

var Device_name = map[int32]string{
	0: "DeviceFalse",
	1: "DeviceMac",
	2: "DeviceWin",
	3: "DeviceAndroid",
	4: "DeviceIos",
	5: "DeviceWeb",
	6: "DeviceMiniProgram",
}

var Device_value = map[string]int32{
	"DeviceFalse":       0,
	"DeviceMac":         1,
	"DeviceWin":         2,
	"DeviceAndroid":     3,
	"DeviceIos":         4,
	"DeviceWeb":         5,
	"DeviceMiniProgram": 6,
}

func (x Device) String() string {
	return proto.EnumName(Device_name, int32(x))
}

func (Device) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4c16552f9fdb66d8, []int{0}
}

type Gender int32

const (
	Gender_GenderUnknown Gender = 0
	Gender_GenderMale    Gender = 1
	Gender_GenderFemale  Gender = 2
	Gender_GenderSecret  Gender = 3
)

var Gender_name = map[int32]string{
	0: "GenderUnknown",
	1: "GenderMale",
	2: "GenderFemale",
	3: "GenderSecret",
}

var Gender_value = map[string]int32{
	"GenderUnknown": 0,
	"GenderMale":    1,
	"GenderFemale":  2,
	"GenderSecret":  3,
}

func (x Gender) String() string {
	return proto.EnumName(Gender_name, int32(x))
}

func (Gender) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4c16552f9fdb66d8, []int{1}
}

type RequestMeta struct {
	TraceId    string `protobuf:"bytes,1,opt,name=trace_id,json=traceId,proto3" json:"trace_id,omitempty"`
	Device     Device `protobuf:"varint,2,opt,name=device,proto3,enum=model.Device" json:"device,omitempty"`
	AppName    string `protobuf:"bytes,3,opt,name=app_name,json=appName,proto3" json:"app_name,omitempty"`
	AppVersion string `protobuf:"bytes,4,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	DeviceId   string `protobuf:"bytes,5,opt,name=device_id,json=deviceId,proto3" json:"device_id,omitempty"`
	UserIp     string `protobuf:"bytes,6,opt,name=user_ip,json=userIp,proto3" json:"user_ip,omitempty"`
	Lat        string `protobuf:"bytes,7,opt,name=lat,proto3" json:"lat,omitempty"`
	Lng        string `protobuf:"bytes,8,opt,name=lng,proto3" json:"lng,omitempty"`
	UserId     int64  `protobuf:"varint,9,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	CreatedOn  int64  `protobuf:"varint,10,opt,name=created_on,json=createdOn,proto3" json:"created_on,omitempty"`
}

func (m *RequestMeta) Reset()         { *m = RequestMeta{} }
func (m *RequestMeta) String() string { return proto.CompactTextString(m) }
func (*RequestMeta) ProtoMessage()    {}
func (*RequestMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c16552f9fdb66d8, []int{0}
}
func (m *RequestMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestMeta.Merge(m, src)
}
func (m *RequestMeta) XXX_Size() int {
	return m.Size()
}
func (m *RequestMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestMeta.DiscardUnknown(m)
}

var xxx_messageInfo_RequestMeta proto.InternalMessageInfo

func (m *RequestMeta) GetTraceId() string {
	if m != nil {
		return m.TraceId
	}
	return ""
}

func (m *RequestMeta) GetDevice() Device {
	if m != nil {
		return m.Device
	}
	return Device_DeviceFalse
}

func (m *RequestMeta) GetAppName() string {
	if m != nil {
		return m.AppName
	}
	return ""
}

func (m *RequestMeta) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *RequestMeta) GetDeviceId() string {
	if m != nil {
		return m.DeviceId
	}
	return ""
}

func (m *RequestMeta) GetUserIp() string {
	if m != nil {
		return m.UserIp
	}
	return ""
}

func (m *RequestMeta) GetLat() string {
	if m != nil {
		return m.Lat
	}
	return ""
}

func (m *RequestMeta) GetLng() string {
	if m != nil {
		return m.Lng
	}
	return ""
}

func (m *RequestMeta) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *RequestMeta) GetCreatedOn() int64 {
	if m != nil {
		return m.CreatedOn
	}
	return 0
}

// 用户auth信息
type UserAuth struct {
	// 用户的id
	UserId int64 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	// 用户鉴权用的token,jwt的token,24小时过期，用refresh-token去刷新使用
	// 每次需要放在header:x-token中传过来
	Token string `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	// 刷新的token
	RefreshToken string `protobuf:"bytes,3,opt,name=refresh_token,json=refreshToken,proto3" json:"refresh_token,omitempty"`
}

func (m *UserAuth) Reset()         { *m = UserAuth{} }
func (m *UserAuth) String() string { return proto.CompactTextString(m) }
func (*UserAuth) ProtoMessage()    {}
func (*UserAuth) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c16552f9fdb66d8, []int{1}
}
func (m *UserAuth) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserAuth) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserAuth.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserAuth) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserAuth.Merge(m, src)
}
func (m *UserAuth) XXX_Size() int {
	return m.Size()
}
func (m *UserAuth) XXX_DiscardUnknown() {
	xxx_messageInfo_UserAuth.DiscardUnknown(m)
}

var xxx_messageInfo_UserAuth proto.InternalMessageInfo

func (m *UserAuth) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserAuth) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *UserAuth) GetRefreshToken() string {
	if m != nil {
		return m.RefreshToken
	}
	return ""
}

type Cnarea2019 struct {
	// 区域的id
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 等级
	Level int32 `protobuf:"varint,2,opt,name=level,proto3" json:"level,omitempty"`
	// 父级行政代码
	ParentCode int64 `protobuf:"varint,3,opt,name=parent_code,json=parentCode,proto3" json:"parent_code,omitempty"`
	// 行政代码
	AreaCode int64 `protobuf:"varint,4,opt,name=area_code,json=areaCode,proto3" json:"area_code,omitempty"`
	// 邮政编码
	ZipCode int32 `protobuf:"varint,5,opt,name=zip_code,json=zipCode,proto3" json:"zip_code,omitempty"`
	// 区号
	CityCode string `protobuf:"bytes,6,opt,name=city_code,json=cityCode,proto3" json:"city_code,omitempty"`
	// 名称
	Name string `protobuf:"bytes,7,opt,name=name,proto3" json:"name,omitempty"`
	// 简称
	ShortName string `protobuf:"bytes,8,opt,name=short_name,json=shortName,proto3" json:"short_name,omitempty"`
	// 组合名
	MergerName string `protobuf:"bytes,9,opt,name=merger_name,json=mergerName,proto3" json:"merger_name,omitempty"`
	// 拼音
	Pinyin string `protobuf:"bytes,10,opt,name=pinyin,proto3" json:"pinyin,omitempty"`
	// 经度
	Lng float64 `protobuf:"fixed64,11,opt,name=lng,proto3" json:"lng,omitempty"`
	// 纬度
	Lat float64 `protobuf:"fixed64,12,opt,name=lat,proto3" json:"lat,omitempty"`
}

func (m *Cnarea2019) Reset()         { *m = Cnarea2019{} }
func (m *Cnarea2019) String() string { return proto.CompactTextString(m) }
func (*Cnarea2019) ProtoMessage()    {}
func (*Cnarea2019) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c16552f9fdb66d8, []int{2}
}
func (m *Cnarea2019) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cnarea2019) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cnarea2019.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cnarea2019) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cnarea2019.Merge(m, src)
}
func (m *Cnarea2019) XXX_Size() int {
	return m.Size()
}
func (m *Cnarea2019) XXX_DiscardUnknown() {
	xxx_messageInfo_Cnarea2019.DiscardUnknown(m)
}

var xxx_messageInfo_Cnarea2019 proto.InternalMessageInfo

func (m *Cnarea2019) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Cnarea2019) GetLevel() int32 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *Cnarea2019) GetParentCode() int64 {
	if m != nil {
		return m.ParentCode
	}
	return 0
}

func (m *Cnarea2019) GetAreaCode() int64 {
	if m != nil {
		return m.AreaCode
	}
	return 0
}

func (m *Cnarea2019) GetZipCode() int32 {
	if m != nil {
		return m.ZipCode
	}
	return 0
}

func (m *Cnarea2019) GetCityCode() string {
	if m != nil {
		return m.CityCode
	}
	return ""
}

func (m *Cnarea2019) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Cnarea2019) GetShortName() string {
	if m != nil {
		return m.ShortName
	}
	return ""
}

func (m *Cnarea2019) GetMergerName() string {
	if m != nil {
		return m.MergerName
	}
	return ""
}

func (m *Cnarea2019) GetPinyin() string {
	if m != nil {
		return m.Pinyin
	}
	return ""
}

func (m *Cnarea2019) GetLng() float64 {
	if m != nil {
		return m.Lng
	}
	return 0
}

func (m *Cnarea2019) GetLat() float64 {
	if m != nil {
		return m.Lat
	}
	return 0
}

type Gift struct {
	// 礼物id
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	// 礼物封面图
	CoverImg string `protobuf:"bytes,2,opt,name=cover_img,json=coverImg,proto3" json:"cover_img,omitempty"`
	// 礼物的序列帧图
	Imgs []string `protobuf:"bytes,3,rep,name=imgs,proto3" json:"imgs,omitempty"`
	// 礼物价格
	GiftCost int64 `protobuf:"varint,4,opt,name=gift_cost,json=giftCost,proto3" json:"gift_cost,omitempty"`
}

func (m *Gift) Reset()         { *m = Gift{} }
func (m *Gift) String() string { return proto.CompactTextString(m) }
func (*Gift) ProtoMessage()    {}
func (*Gift) Descriptor() ([]byte, []int) {
	return fileDescriptor_4c16552f9fdb66d8, []int{3}
}
func (m *Gift) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Gift) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Gift.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Gift) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Gift.Merge(m, src)
}
func (m *Gift) XXX_Size() int {
	return m.Size()
}
func (m *Gift) XXX_DiscardUnknown() {
	xxx_messageInfo_Gift.DiscardUnknown(m)
}

var xxx_messageInfo_Gift proto.InternalMessageInfo

func (m *Gift) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Gift) GetCoverImg() string {
	if m != nil {
		return m.CoverImg
	}
	return ""
}

func (m *Gift) GetImgs() []string {
	if m != nil {
		return m.Imgs
	}
	return nil
}

func (m *Gift) GetGiftCost() int64 {
	if m != nil {
		return m.GiftCost
	}
	return 0
}

func init() {
	proto.RegisterEnum("model.Device", Device_name, Device_value)
	proto.RegisterEnum("model.Gender", Gender_name, Gender_value)
	proto.RegisterType((*RequestMeta)(nil), "model.RequestMeta")
	proto.RegisterType((*UserAuth)(nil), "model.UserAuth")
	proto.RegisterType((*Cnarea2019)(nil), "model.Cnarea2019")
	proto.RegisterType((*Gift)(nil), "model.Gift")
}

func init() { proto.RegisterFile("model.proto", fileDescriptor_4c16552f9fdb66d8) }

var fileDescriptor_4c16552f9fdb66d8 = []byte{
	// 659 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x54, 0x94, 0xc1, 0x6e, 0xd3, 0x4a,
	0x14, 0x86, 0xe3, 0x38, 0x71, 0xec, 0x93, 0xa6, 0xd7, 0x1d, 0xdd, 0x7b, 0x71, 0x85, 0x08, 0x51,
	0x00, 0x29, 0xea, 0xa2, 0x81, 0xb2, 0x62, 0x83, 0x54, 0x8a, 0x5a, 0x65, 0x51, 0x8a, 0x0c, 0x05,
	0x89, 0x05, 0xd1, 0xc4, 0x3e, 0x75, 0x46, 0xb5, 0x67, 0xdc, 0xf1, 0x24, 0xa8, 0xdd, 0xf0, 0x0a,
	0xbc, 0x00, 0xef, 0xc1, 0x23, 0xb0, 0xec, 0x92, 0x25, 0x6a, 0x5f, 0x04, 0xcd, 0x8c, 0xa3, 0x94,
	0xdd, 0xf9, 0xbf, 0xdf, 0xe7, 0x8f, 0xfc, 0x9f, 0x24, 0xd0, 0x2d, 0x44, 0x8a, 0xf9, 0x6e, 0x29,
	0x85, 0x12, 0xa4, 0x6d, 0xc4, 0xf0, 0x7b, 0x13, 0xba, 0x31, 0x5e, 0x2c, 0xb0, 0x52, 0xc7, 0xa8,
	0x28, 0xd9, 0x06, 0x5f, 0x49, 0x9a, 0xe0, 0x94, 0xa5, 0x91, 0x33, 0x70, 0x46, 0x41, 0xdc, 0x31,
	0x7a, 0x92, 0x92, 0x27, 0xe0, 0xa5, 0xb8, 0x64, 0x09, 0x46, 0xcd, 0x81, 0x33, 0xda, 0xdc, 0xeb,
	0xed, 0xda, 0xbc, 0xd7, 0x06, 0xc6, 0xb5, 0xa9, 0x13, 0x68, 0x59, 0x4e, 0x39, 0x2d, 0x30, 0x72,
	0x6d, 0x02, 0x2d, 0xcb, 0x37, 0xb4, 0x40, 0xf2, 0x10, 0xba, 0xda, 0x5a, 0xa2, 0xac, 0x98, 0xe0,
	0x51, 0xcb, 0xb8, 0x40, 0xcb, 0xf2, 0x83, 0x25, 0xe4, 0x3e, 0x04, 0x36, 0x45, 0x7f, 0x7c, 0xdb,
	0xd8, 0xbe, 0x05, 0x93, 0x94, 0xdc, 0x83, 0xce, 0xa2, 0x42, 0x39, 0x65, 0x65, 0xe4, 0x19, 0xcb,
	0xd3, 0x72, 0x52, 0x92, 0x10, 0xdc, 0x9c, 0xaa, 0xa8, 0x63, 0xa0, 0x1e, 0x0d, 0xe1, 0x59, 0xe4,
	0xd7, 0x84, 0x67, 0xeb, 0xe5, 0x34, 0x0a, 0x06, 0xce, 0xc8, 0xad, 0x97, 0x53, 0xf2, 0x00, 0x20,
	0x91, 0x48, 0x15, 0xa6, 0x53, 0xc1, 0x23, 0x30, 0x5e, 0x50, 0x93, 0x13, 0x3e, 0xfc, 0x0c, 0xfe,
	0x69, 0x85, 0x72, 0x7f, 0xa1, 0xe6, 0x77, 0x33, 0x9c, 0xbf, 0x32, 0xfe, 0x85, 0xb6, 0x12, 0xe7,
	0xc8, 0x4d, 0x31, 0x41, 0x6c, 0x05, 0x79, 0x04, 0x3d, 0x89, 0x67, 0x12, 0xab, 0xf9, 0xd4, 0xba,
	0xb6, 0x8d, 0x8d, 0x1a, 0xbe, 0xd7, 0x6c, 0xf8, 0xa3, 0x09, 0x70, 0xc0, 0xa9, 0x44, 0xba, 0xf7,
	0xf4, 0xd9, 0x0b, 0xb2, 0x09, 0xcd, 0x3a, 0xbd, 0x1d, 0x37, 0x99, 0x49, 0xce, 0x71, 0x89, 0xb9,
	0x49, 0x6e, 0xc7, 0x56, 0xe8, 0x1e, 0x4b, 0x2a, 0x91, 0xab, 0x69, 0x22, 0x52, 0xdb, 0xb2, 0x1b,
	0x83, 0x45, 0x07, 0x22, 0x45, 0xdd, 0xa3, 0x8e, 0xb4, 0x76, 0xcb, 0xd8, 0xbe, 0x06, 0xc6, 0xdc,
	0x06, 0xff, 0x8a, 0x95, 0xd6, 0x6b, 0x9b, 0xd8, 0xce, 0x15, 0x2b, 0x57, 0x7b, 0x09, 0x53, 0x97,
	0xd6, 0xb3, 0x25, 0xfb, 0x1a, 0x18, 0x93, 0x40, 0xcb, 0x1c, 0xd5, 0xf6, 0x6c, 0x66, 0xdd, 0x5e,
	0x35, 0x17, 0x52, 0xd9, 0x73, 0xdb, 0xbe, 0x03, 0x43, 0x56, 0x07, 0x2f, 0x50, 0x66, 0x28, 0xad,
	0x1f, 0xd8, 0x83, 0x5b, 0x64, 0x1e, 0xf8, 0x1f, 0xbc, 0x92, 0xf1, 0x4b, 0x66, 0x9b, 0x0f, 0xe2,
	0x5a, 0xad, 0x0e, 0xd8, 0x1d, 0x38, 0x23, 0xc7, 0x1e, 0xb0, 0x3e, 0xf2, 0x46, 0x4d, 0xa8, 0x1a,
	0xa6, 0xd0, 0x3a, 0x62, 0x67, 0xea, 0x4e, 0x67, 0xae, 0xe9, 0x4c, 0xbf, 0x84, 0x58, 0xea, 0x3b,
	0x15, 0x59, 0x7d, 0x11, 0xdf, 0x80, 0x49, 0x91, 0xe9, 0x97, 0x60, 0x45, 0x56, 0x45, 0xee, 0xc0,
	0xd5, 0x2f, 0xa1, 0x67, 0xbd, 0x90, 0xb1, 0x33, 0x5d, 0x66, 0xa5, 0x56, 0x6d, 0x69, 0x70, 0x20,
	0x2a, 0xb5, 0xf3, 0x15, 0x3c, 0xfb, 0x05, 0x27, 0xff, 0x40, 0xd7, 0x4e, 0x87, 0x34, 0xaf, 0x30,
	0x6c, 0x90, 0x1e, 0x04, 0x16, 0x1c, 0xd3, 0x24, 0x74, 0xd6, 0xf2, 0x23, 0xe3, 0x61, 0x93, 0x6c,
	0x41, 0xcf, 0xca, 0x7d, 0x9e, 0x4a, 0xc1, 0xd2, 0xd0, 0x5d, 0x3f, 0x31, 0x11, 0x55, 0xd8, 0xba,
	0xb3, 0x80, 0xb3, 0xb0, 0x4d, 0xfe, 0x83, 0xad, 0x3a, 0x8e, 0x71, 0xf6, 0x56, 0x8a, 0x4c, 0xd2,
	0x22, 0xf4, 0x76, 0x4e, 0xc0, 0x3b, 0x42, 0x9e, 0xa2, 0xd4, 0x89, 0x76, 0x3a, 0xe5, 0xe7, 0x5c,
	0x7c, 0xe1, 0x61, 0x83, 0x6c, 0x02, 0x58, 0x74, 0x4c, 0x73, 0x0c, 0x1d, 0x12, 0xc2, 0x86, 0xd5,
	0x87, 0x58, 0x68, 0xd2, 0x5c, 0x93, 0x77, 0x98, 0x48, 0x54, 0xa1, 0xfb, 0xea, 0xe5, 0xcf, 0x9b,
	0xbe, 0x73, 0x7d, 0xd3, 0x77, 0x7e, 0xdf, 0xf4, 0x9d, 0x6f, 0xb7, 0xfd, 0xc6, 0xf5, 0x6d, 0xbf,
	0xf1, 0xeb, 0xb6, 0xdf, 0xf8, 0xf4, 0x38, 0x63, 0x6a, 0xbe, 0x98, 0xed, 0x26, 0xa2, 0x18, 0x5f,
	0x54, 0x22, 0x39, 0x1f, 0x5f, 0xb0, 0x62, 0x9c, 0xb3, 0xd9, 0xd8, 0xfc, 0x67, 0x8c, 0xcd, 0xef,
	0x7d, 0xe6, 0x19, 0xf1, 0xfc, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd4, 0x64, 0x34, 0xd5, 0x4f,
	0x04, 0x00, 0x00,
}

func (m *RequestMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestMeta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestMeta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedOn != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.CreatedOn))
		i--
		dAtA[i] = 0x50
	}
	if m.UserId != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x48
	}
	if len(m.Lng) > 0 {
		i -= len(m.Lng)
		copy(dAtA[i:], m.Lng)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Lng)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Lat) > 0 {
		i -= len(m.Lat)
		copy(dAtA[i:], m.Lat)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Lat)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.UserIp) > 0 {
		i -= len(m.UserIp)
		copy(dAtA[i:], m.UserIp)
		i = encodeVarintModel(dAtA, i, uint64(len(m.UserIp)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.DeviceId) > 0 {
		i -= len(m.DeviceId)
		copy(dAtA[i:], m.DeviceId)
		i = encodeVarintModel(dAtA, i, uint64(len(m.DeviceId)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AppVersion) > 0 {
		i -= len(m.AppVersion)
		copy(dAtA[i:], m.AppVersion)
		i = encodeVarintModel(dAtA, i, uint64(len(m.AppVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.AppName) > 0 {
		i -= len(m.AppName)
		copy(dAtA[i:], m.AppName)
		i = encodeVarintModel(dAtA, i, uint64(len(m.AppName)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Device != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.Device))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TraceId) > 0 {
		i -= len(m.TraceId)
		copy(dAtA[i:], m.TraceId)
		i = encodeVarintModel(dAtA, i, uint64(len(m.TraceId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UserAuth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserAuth) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserAuth) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RefreshToken) > 0 {
		i -= len(m.RefreshToken)
		copy(dAtA[i:], m.RefreshToken)
		i = encodeVarintModel(dAtA, i, uint64(len(m.RefreshToken)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Token) > 0 {
		i -= len(m.Token)
		copy(dAtA[i:], m.Token)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Token)))
		i--
		dAtA[i] = 0x12
	}
	if m.UserId != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cnarea2019) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cnarea2019) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cnarea2019) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Lat != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lat))))
		i--
		dAtA[i] = 0x61
	}
	if m.Lng != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Lng))))
		i--
		dAtA[i] = 0x59
	}
	if len(m.Pinyin) > 0 {
		i -= len(m.Pinyin)
		copy(dAtA[i:], m.Pinyin)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Pinyin)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.MergerName) > 0 {
		i -= len(m.MergerName)
		copy(dAtA[i:], m.MergerName)
		i = encodeVarintModel(dAtA, i, uint64(len(m.MergerName)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ShortName) > 0 {
		i -= len(m.ShortName)
		copy(dAtA[i:], m.ShortName)
		i = encodeVarintModel(dAtA, i, uint64(len(m.ShortName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintModel(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CityCode) > 0 {
		i -= len(m.CityCode)
		copy(dAtA[i:], m.CityCode)
		i = encodeVarintModel(dAtA, i, uint64(len(m.CityCode)))
		i--
		dAtA[i] = 0x32
	}
	if m.ZipCode != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ZipCode))
		i--
		dAtA[i] = 0x28
	}
	if m.AreaCode != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.AreaCode))
		i--
		dAtA[i] = 0x20
	}
	if m.ParentCode != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.ParentCode))
		i--
		dAtA[i] = 0x18
	}
	if m.Level != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Gift) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Gift) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Gift) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.GiftCost != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.GiftCost))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Imgs) > 0 {
		for iNdEx := len(m.Imgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Imgs[iNdEx])
			copy(dAtA[i:], m.Imgs[iNdEx])
			i = encodeVarintModel(dAtA, i, uint64(len(m.Imgs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.CoverImg) > 0 {
		i -= len(m.CoverImg)
		copy(dAtA[i:], m.CoverImg)
		i = encodeVarintModel(dAtA, i, uint64(len(m.CoverImg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintModel(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintModel(dAtA []byte, offset int, v uint64) int {
	offset -= sovModel(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RequestMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TraceId)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Device != 0 {
		n += 1 + sovModel(uint64(m.Device))
	}
	l = len(m.AppName)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.DeviceId)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.UserIp)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Lat)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Lng)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.UserId != 0 {
		n += 1 + sovModel(uint64(m.UserId))
	}
	if m.CreatedOn != 0 {
		n += 1 + sovModel(uint64(m.CreatedOn))
	}
	return n
}

func (m *UserAuth) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovModel(uint64(m.UserId))
	}
	l = len(m.Token)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.RefreshToken)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	return n
}

func (m *Cnarea2019) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovModel(uint64(m.Id))
	}
	if m.Level != 0 {
		n += 1 + sovModel(uint64(m.Level))
	}
	if m.ParentCode != 0 {
		n += 1 + sovModel(uint64(m.ParentCode))
	}
	if m.AreaCode != 0 {
		n += 1 + sovModel(uint64(m.AreaCode))
	}
	if m.ZipCode != 0 {
		n += 1 + sovModel(uint64(m.ZipCode))
	}
	l = len(m.CityCode)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.ShortName)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.MergerName)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	l = len(m.Pinyin)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if m.Lng != 0 {
		n += 9
	}
	if m.Lat != 0 {
		n += 9
	}
	return n
}

func (m *Gift) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovModel(uint64(m.Id))
	}
	l = len(m.CoverImg)
	if l > 0 {
		n += 1 + l + sovModel(uint64(l))
	}
	if len(m.Imgs) > 0 {
		for _, s := range m.Imgs {
			l = len(s)
			n += 1 + l + sovModel(uint64(l))
		}
	}
	if m.GiftCost != 0 {
		n += 1 + sovModel(uint64(m.GiftCost))
	}
	return n
}

func sovModel(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozModel(x uint64) (n int) {
	return sovModel(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RequestMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TraceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Device", wireType)
			}
			m.Device = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Device |= Device(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lat = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lng", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lng = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedOn", wireType)
			}
			m.CreatedOn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatedOn |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserAuth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserAuth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserAuth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Token", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Token = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RefreshToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RefreshToken = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cnarea2019) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cnarea2019: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cnarea2019: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentCode", wireType)
			}
			m.ParentCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ParentCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AreaCode", wireType)
			}
			m.AreaCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AreaCode |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZipCode", wireType)
			}
			m.ZipCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ZipCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CityCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CityCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ShortName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ShortName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MergerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MergerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pinyin", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pinyin = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lng", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lng = float64(math.Float64frombits(v))
		case 12:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lat", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Lat = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Gift) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowModel
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Gift: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Gift: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CoverImg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CoverImg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthModel
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthModel
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Imgs = append(m.Imgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GiftCost", wireType)
			}
			m.GiftCost = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowModel
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GiftCost |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipModel(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthModel
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipModel(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowModel
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowModel
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthModel
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupModel
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthModel
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthModel        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowModel          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupModel = fmt.Errorf("proto: unexpected end of group")
)
